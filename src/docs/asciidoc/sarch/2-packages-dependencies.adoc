[#dependencies]
== Packages & Dependencies

Het is misschien onverwacht, maar een heel groot gedeelte van het werk van een Software Architect zit in het bijhouden en managen van dependencies. Een dependency is letterlijk iets waar je afhankelijk van bent: een ander stukje code dat je nodig hebt om je werk te doen. 

De terminologie is een beetje slordig, we kunnen zowel zeggen dat we een dependency op dat stuk code hebben, maar ook dat dat stuk code een dependency is. De formele definitie van Software Architecture praat over de "Software Elements, Relations among them, and properties of both". Met het praten over dependencies praten we dus zowel over de 'elements', en over die 'relations'. Als we het daarnaast ook nog over de 'properties' hebben, dan hebben we het allemaal wel gehad.

[quote, Documenting Software Architectures (2010), herhaling]
"The software architecture of a computing system is the set of structures needed to reason about the system, which comprise software elements, relations among them, and properties of both."


=== Waarom Dependencies

Je hebt 't nodig.

Het is zeer ongebruikelijk om een programma helemaal op eigen kracht te schrijven. Zelfs de String class is strict genomen onderdeel van de Standard Library in Java, je zou dan alleen de primitive (kleine letter) classes kunnen gebruiken, en alle andere zelf moeten maken.

Maar er zijn zat andere dingen waar je aan kan denken:

* Zonder een library als JavaFX is het een enorm werk om een knop op het scherm te tekenen. Dan zou je zelf alle OS-calls moeten schrijven om de juiste pixels te tekenen, click-functionaliteit te implementeren, etc.
* Datum/tijd berekeningen kunnen erg tricky worden met schrikkeljaren, zomer/wintertijd etc. Dan is het fijn dat dingen als LocalDate en LocalDateTime bestaan.
* Je kunt het zo gek niet bedenken, of er is wel een library voor

=== Risicos van Dependencies

* Leftpad
* Log4Shell
* ...

=== Packages

Het woord package is nogal overloaded. Een Java package is net iets anders dan een NPM package, en woorden als project of module hebben ook per programmeertaal een andere bijklank.

Gelukkig zitten Java-packages en UML packages redelijk dicht bij elkaar. Een package in deze zin is louter een groepje classes (en andere 'inner' packages).

[#coupling]
=== Dependencies & Coupling

Met Coupling bedoelen we een verbinding tussen verschillende groepen code (zoals classes). Als een wijziging in stukje code B tot een mogelijke wijziging in code A zou kunnen leiden (genoeg dat je het even moet dubbelchecken of het wel goed gaat), dan is A gekoppeld aan B.

In de meeste gevallen impliceert een Dependency automatisch dat er Coupling tussen stukken code is (want als de dependency stuk gaat, dan moet je aan het werk). De vergelijking is echter net-niet één-op-één. Je kunt bijv. een class schrijven die al je data netjes naar een bestand schrijft met de java.nio.file.Files class. Je applicatie is dan nog wel Dependent java.nio.file.Files, en is nog wel een beetje gecoupled aan java.nio.file.Files, maar een heel stuk minder als wanneer je in twintig verschillende classes in je code-base met het handje met java.nio.file.Files aan het manipuleren bent.

Coupling is dus een schaal, je kunt 'een beetje' gecoupled zijn, of heel erg. Afhankelijk hoe groot evt. problemen in je applicatie door de rest van je code verspreiden. Er zijn veel soorten coupling, in deze cursus focussen we vooral op Type-level-coupling (dus als we code B wijzigen, kunnen we code A ineens niet meer compilen), maar er zijn vele soorten (bijv. qua timing, als we er vanuit gaan dat een bepaalde methode 'vast wel binnen een seconde klaar is' en daar met een Thread.sleep omheen werken). Zie voor meer bijv. de website https://connascence.io/[Connasence.io]footnote:[Coupling & Connascence zijn nagenoeg synoniemen. Connascence is een iets nieuwere term die probeert 'Coupling en meer' te zijn, maar het is me niet helemaal duidelijk waarom al dat meer niet ook gewoon coupling is...]

==== Law of Demeter


Dependencies (en de daaruit voortvloeiende coupling) zijn de oorzaak van een overvloed van onze problemen. Gelukkig is er een duidelijke oplossing, de "Fundamental theorem of software engineering":

[quote, David Wheeler (????)]
"We can solve any problem by introducing an extra level of indirection."

En de komende hoofdstukken kijken we naar verschillende vormen die zo'n level of indirection kan aannemen.


